<div class="relative w-full h-full bg-slate-900 rounded-xl overflow-hidden">
  <canvas id="antifragile-canvas" class="w-full h-full block"></canvas>
  
  <!-- Controls -->
  <div class="absolute bottom-6 left-1/2 -translate-x-1/2 flex flex-col items-center gap-2 w-3/4 max-w-sm z-10 select-none">
     <div class="flex items-center justify-between w-full text-slate-400 text-xs font-mono">
        <span>CALM</span>
        <span class="text-white font-bold tracking-widest">STRESSOR INTENSITY</span>
        <span>CHAOS</span>
     </div>
     <input type="range" min="0" max="100" value="20" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-emerald-500 hover:accent-emerald-400 transition-colors" id="shock-slider">
  </div>

  <!-- Labels -->
  <div class="absolute top-8 left-0 w-full flex justify-around px-4 pointer-events-none select-none">
      <div class="text-center w-1/3">
          <div class="text-red-400 font-bold text-sm tracking-wider">FRAGILE</div>
          <div class="text-red-400/50 text-xs mt-1">Shatters under stress</div>
      </div>
      <div class="text-center w-1/3">
          <div class="text-slate-300 font-bold text-sm tracking-wider">ROBUST</div>
          <div class="text-slate-300/50 text-xs mt-1">Resists stress</div>
      </div>
      <div class="text-center w-1/3">
          <div class="text-emerald-400 font-bold text-sm tracking-wider">ANTIFRAGILE</div>
          <div class="text-emerald-400/50 text-xs mt-1">Gains from stress</div>
      </div>
  </div>
</div>

<script is:inline>
    (function() {
        console.log("AntifragileCanvas: script execution started");

        function initAntifragileCanvas() {
            console.log("AntifragileCanvas: init called");
            const canvas = document.getElementById('antifragile-canvas');
            const slider = document.getElementById('shock-slider');
            
            if (!canvas || !slider) {
                console.log("AntifragileCanvas: canvas or slider not found", { canvas, slider });
                return;
            }

            // Prevent double initialization on the same element if we attach a custom property
            if (canvas._initialized) {
                console.log("AntifragileCanvas: already initialized");
                return;
            }
            canvas._initialized = true;

            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error("AntifragileCanvas: 2d context not available");
                return;
            }

            let width = canvas.width = canvas.offsetWidth;
            let height = canvas.height = canvas.offsetHeight;
            let shockIntensity = parseInt(slider.value) / 100; // 0 to 1
            let isRunning = true;

            console.log("AntifragileCanvas: Setup complete, width:", width, "height:", height);

            // Event Listener
            const onInput = (e) => {
                shockIntensity = parseInt(e.target.value) / 100;
            };
            slider.addEventListener('input', onInput);

            // Resize
            const resizeObserver = new ResizeObserver(() => {
                if (!canvas) return;
                width = canvas.width = canvas.offsetWidth;
                height = canvas.height = canvas.offsetHeight;
                initObjects();
            });
            if (canvas.parentElement) {
                resizeObserver.observe(canvas.parentElement);
            }

            // --- Game Objects ---
            
            // 1. Fragile (Glass Cup)
            let fragileObj = {
                x: 0, y: 0, 
                baseY: 0,
                health: 100,
                state: 'intact', // intact, cracked, broken
                shake: 0,
                shards: []
            };

            // 2. Robust (Shield/Rock)
            let robustObj = {
                x: 0, y: 0,
                baseY: 0,
                shake: 0
            };

            // 3. Antifragile (Fire)
            let antifragileObj = {
                x: 0, y: 0,
                baseY: 0,
                size: 1, // Multiplier
                particles: [],
                targetSize: 1
            };

            let shockwaves = [];
            let time = 0;

            function initObjects() {
                const centerY = height * 0.6;
                const sectionWidth = width / 3;

                fragileObj.x = sectionWidth * 0.5;
                fragileObj.y = centerY;
                fragileObj.baseY = centerY;
                fragileObj.health = 100;
                fragileObj.state = 'intact';
                fragileObj.shards = [];

                robustObj.x = sectionWidth * 1.5;
                robustObj.y = centerY;
                robustObj.baseY = centerY;

                antifragileObj.x = sectionWidth * 2.5;
                antifragileObj.y = centerY;
                antifragileObj.baseY = centerY;
                antifragileObj.particles = [];
            }

            initObjects();

            // --- Logic ---

            function spawnShockwave() {
                // Spawn probability increases with intensity
                if (Math.random() < 0.02 + (shockIntensity * 0.1)) {
                    shockwaves.push({
                        x: -50,
                        speed: 5 + Math.random() * 5 + (shockIntensity * 10),
                        strength: shockIntensity
                    });
                }
            }

            function update() {
                time++;
                spawnShockwave();

                // Update Shockwaves
                for (let i = shockwaves.length - 1; i >= 0; i--) {
                    let wave = shockwaves[i];
                    wave.x += wave.speed;

                    // Collision Detection & Effect Application
                    // We define 3 zones. When wave passes center of object, apply effect.
                    
                    // Fragile Zone
                    if (Math.abs(wave.x - fragileObj.x) < wave.speed) {
                        if (fragileObj.state !== 'broken') {
                            fragileObj.shake = wave.strength * 20;
                            if (wave.strength > 0.4) {
                                fragileObj.health -= wave.strength * 40;
                            }
                            if (fragileObj.health <= 0) {
                                fragileObj.state = 'broken';
                                // Create shards
                                for(let k=0; k<12; k++) {
                                    fragileObj.shards.push({
                                        x: fragileObj.x,
                                        y: fragileObj.y,
                                        vx: (Math.random() - 0.5) * 10,
                                        vy: (Math.random() - 1) * 10,
                                        rot: Math.random() * Math.PI
                                    });
                                }
                            } else if (fragileObj.health < 60) {
                                fragileObj.state = 'cracked';
                            }
                        }
                    }

                    // Robust Zone
                    if (Math.abs(wave.x - robustObj.x) < wave.speed) {
                        robustObj.shake = wave.strength * 5; // Shakes less
                    }

                    // Antifragile Zone
                    if (Math.abs(wave.x - antifragileObj.x) < wave.speed) {
                        // Grows with stress!
                        antifragileObj.targetSize = Math.min(2.5, antifragileObj.targetSize + (wave.strength * 0.2));
                        // Add burst of particles
                        for(let k=0; k<5; k++) {
                            antifragileObj.particles.push(createFireParticle(antifragileObj.x, antifragileObj.y, antifragileObj.size));
                        }
                    }

                    if (wave.x > width) {
                        shockwaves.splice(i, 1);
                    }
                }

                // Update Objects
                
                // Fragile
                if (fragileObj.shake > 0) fragileObj.shake *= 0.9;
                if (fragileObj.state === 'broken') {
                     // Reset slowly if broken
                     if (Math.random() < 0.005) {
                         fragileObj.state = 'intact';
                         fragileObj.health = 100;
                         fragileObj.shards = [];
                     }
                     // Move shards
                     fragileObj.shards.forEach(s => {
                         s.x += s.vx;
                         s.y += s.vy;
                         s.vy += 0.5; // gravity
                     });
                }

                // Robust
                if (robustObj.shake > 0) robustObj.shake *= 0.9;

                // Antifragile
                // Decay size slowly if no stress, but minimum is 1
                antifragileObj.targetSize = Math.max(1.0, antifragileObj.targetSize - 0.001);
                antifragileObj.size += (antifragileObj.targetSize - antifragileObj.size) * 0.05;
                
                // Fire particles
                // Always spawn some base fire
                if (Math.random() < 0.5 * antifragileObj.size) {
                     antifragileObj.particles.push(createFireParticle(antifragileObj.x, antifragileObj.y, antifragileObj.size));
                }
                
                for (let i = antifragileObj.particles.length - 1; i >= 0; i--) {
                    let p = antifragileObj.particles[i];
                    p.y -= p.speedY;
                    p.x += Math.sin(time * 0.1 + p.offset) * 0.5;
                    p.life -= p.decay;
                    p.size -= p.decay * 2;
                    if (p.life <= 0 || p.size <= 0) {
                        antifragileObj.particles.splice(i, 1);
                    }
                }
            }

            function createFireParticle(x, y, scale) {
                return {
                    x: x + (Math.random() - 0.5) * 30 * scale,
                    y: y + 20 * scale,
                    speedY: (1 + Math.random() * 2) * scale,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.02,
                    size: (5 + Math.random() * 10) * scale,
                    offset: Math.random() * 100,
                    color: Math.random() > 0.5 ? '#fbbf24' : '#ef4444' // Yellow or Red
                };
            }

            function draw() {
                if (!ctx || !isRunning) return;
                
                // Check if canvas is still attached to DOM
                if (!document.body.contains(canvas)) {
                    isRunning = false;
                    resizeObserver.disconnect();
                    slider.removeEventListener('input', onInput);
                    return;
                }

                ctx.clearRect(0, 0, width, height);

                // Draw Shockwaves
                ctx.strokeStyle = `rgba(255, 255, 255, 0.1)`;
                ctx.lineWidth = 2;
                shockwaves.forEach(w => {
                    ctx.beginPath();
                    ctx.moveTo(w.x, 0);
                    ctx.lineTo(w.x, height);
                    ctx.stroke();
                    
                    // Draw "Wind" effect
                    ctx.fillStyle = `rgba(255, 255, 255, ${w.strength * 0.3})`;
                    ctx.fillRect(w.x - 20, 0, 40, height);
                });

                // Draw Fragile (Glass)
                if (fragileObj.state !== 'broken') {
                    const shakeX = (Math.random() - 0.5) * fragileObj.shake;
                    const shakeY = (Math.random() - 0.5) * fragileObj.shake;
                    
                    ctx.save();
                    ctx.translate(fragileObj.x + shakeX, fragileObj.y + shakeY);
                    
                    // Glass Body
                    ctx.fillStyle = 'rgba(248, 113, 113, 0.2)'; // Red tint
                    ctx.strokeStyle = '#f87171';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.rect(-20, -30, 40, 60);
                    ctx.fill();
                    ctx.stroke();

                    // Cracks
                    if (fragileObj.state === 'cracked') {
                        ctx.beginPath();
                        ctx.moveTo(-10, -20);
                        ctx.lineTo(5, 0);
                        ctx.lineTo(-5, 15);
                        ctx.stroke();
                    }
                    ctx.restore();
                } else {
                    // Draw Shards
                    ctx.fillStyle = '#f87171';
                    fragileObj.shards.forEach(s => {
                        ctx.save();
                        ctx.translate(s.x, s.y);
                        ctx.rotate(s.rot);
                        ctx.fillRect(-3, -3, 6, 6);
                        ctx.restore();
                    });
                }

                // Draw Robust (Shield)
                const robShakeX = (Math.random() - 0.5) * robustObj.shake;
                ctx.save();
                ctx.translate(robustObj.x + robShakeX, robustObj.y);
                
                ctx.fillStyle = '#cbd5e1'; // Slate-300
                ctx.beginPath();
                // Shield shape
                ctx.moveTo(0, -30);
                ctx.lineTo(25, -20);
                ctx.lineTo(25, 10);
                ctx.lineTo(0, 30);
                ctx.lineTo(-25, 10);
                ctx.lineTo(-25, -20);
                ctx.closePath();
                ctx.fill();
                
                // Inner detail
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();


                // Draw Antifragile (Fire)
                ctx.save();
                // Glow
                const glowSize = 100 * antifragileObj.size;
                const gradient = ctx.createRadialGradient(antifragileObj.x, antifragileObj.y, 0, antifragileObj.x, antifragileObj.y, glowSize);
                gradient.addColorStop(0, 'rgba(16, 185, 129, 0.2)'); // Emerald glow
                gradient.addColorStop(1, 'rgba(16, 185, 129, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(antifragileObj.x - glowSize, antifragileObj.y - glowSize, glowSize * 2, glowSize * 2);

                // Particles
                antifragileObj.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color === '#ef4444' ? '#34d399' : '#10b981'; // Green fire for "Growth/Life"
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.restore();
                
                // Draw floor
                ctx.strokeStyle = '#334155';
                ctx.beginPath();
                ctx.moveTo(0, height * 0.6 + 40);
                ctx.lineTo(width, height * 0.6 + 40);
                ctx.stroke();

                requestAnimationFrame(draw);
            }

            // Loop
            function loop() {
                if (!isRunning) return;
                update();
                // Draw is self-looping via requestAnimationFrame
            }
            
            // Start update loop
            const updateInterval = setInterval(() => {
                if (!isRunning) {
                    clearInterval(updateInterval);
                    return;
                }
                update();
            }, 1000/60);

            // Start draw loop
            draw();
            console.log("AntifragileCanvas: Animation started");
        }

        // Run when DOM is ready or view transition completes
        if (document.readyState !== 'loading') {
            initAntifragileCanvas();
        } else {
            document.addEventListener('DOMContentLoaded', initAntifragileCanvas);
        }
        // Support Astro View Transitions if enabled in future
        document.addEventListener('astro:page-load', initAntifragileCanvas);
    })();
</script>