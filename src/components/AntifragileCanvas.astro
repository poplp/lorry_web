<div class="relative w-full h-full bg-slate-900 rounded-xl overflow-hidden">
  <canvas id="antifragile-canvas" class="w-full h-full block"></canvas>
  
  <!-- Controls -->
  <div class="absolute bottom-6 left-1/2 -translate-x-1/2 flex flex-col items-center gap-2 w-3/4 max-w-sm z-10 select-none">
     <div class="flex items-center justify-between w-full text-slate-400 text-xs font-mono">
        <span>CALM</span>
        <span class="text-white font-bold tracking-widest">STRESSOR INTENSITY</span>
        <span>CHAOS</span>
     </div>
     <input type="range" min="0" max="100" value="20" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-emerald-500 hover:accent-emerald-400 transition-colors" id="shock-slider">
  </div>

  <!-- Labels -->
  <div class="absolute top-8 left-0 w-full flex justify-around px-4 pointer-events-none select-none">
      <div class="text-center w-1/3">
          <div class="text-red-400 font-bold text-sm tracking-wider">FRAGILE</div>
          <div class="text-red-400/50 text-xs mt-1">Shatters under stress</div>
      </div>
      <div class="text-center w-1/3">
          <div class="text-slate-300 font-bold text-sm tracking-wider">ROBUST</div>
          <div class="text-slate-300/50 text-xs mt-1">Resists stress</div>
      </div>
      <div class="text-center w-1/3">
          <div class="text-emerald-400 font-bold text-sm tracking-wider">ANTIFRAGILE</div>
          <div class="text-emerald-400/50 text-xs mt-1">Gains from stress</div>
      </div>
  </div>
</div>

<script is:inline>
    (function() {
        console.log("AntifragileCanvas: script execution started");

        function initAntifragileCanvas() {
            console.log("AntifragileCanvas: init called");
            const canvas = document.getElementById('antifragile-canvas');
            const slider = document.getElementById('shock-slider');
            
            if (!canvas || !slider) {
                console.log("AntifragileCanvas: canvas or slider not found", { canvas, slider });
                return;
            }

            // Prevent double initialization on the same element
            if (canvas._initialized) {
                console.log("AntifragileCanvas: already initialized");
                return;
            }
            canvas._initialized = true;

            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error("AntifragileCanvas: 2d context not available");
                return;
            }

            let width = canvas.width = canvas.offsetWidth;
            let height = canvas.height = canvas.offsetHeight;
            let stressLevel = parseInt(slider.value) / 100; // 0 to 1
            let isRunning = true;

            // Colors
            const colors = {
                fragile: '#ef4444', // Red-500
                robust: '#94a3b8',  // Slate-400
                antifragile: '#10b981', // Emerald-500
                weight: '#f1f5f9',  // Slate-100
                text: '#cbd5e1'     // Slate-300
            };

            // Event Listener
            const onInput = (e) => {
                stressLevel = parseInt(e.target.value) / 100;
            };
            slider.addEventListener('input', onInput);

            // Resize
            const resizeObserver = new ResizeObserver(() => {
                if (!canvas) return;
                width = canvas.width = canvas.offsetWidth;
                height = canvas.height = canvas.offsetHeight;
                initObjects();
            });
            if (canvas.parentElement) {
                resizeObserver.observe(canvas.parentElement);
            }

            // --- Game Objects ---
            
            let objects = {
                fragile: { x: 0, y: 0, w: 60, h: 60, state: 'intact', health: 1, shards: [] },
                robust: { x: 0, y: 0, r: 35, offset: 0 },
                antifragile: { x: 0, y: 0, r: 30, targetR: 30, pulse: 0 }
            };

            let weights = []; // Falling objects
            let particles = []; // Effects

            function initObjects() {
                const centerY = height * 0.7;
                const sectionWidth = width / 3;

                // Position objects in center of their 1/3 sections
                objects.fragile.x = sectionWidth * 0.5;
                objects.fragile.y = centerY;
                objects.fragile.state = 'intact';
                objects.fragile.shards = [];

                objects.robust.x = sectionWidth * 1.5;
                objects.robust.y = centerY;

                objects.antifragile.x = sectionWidth * 2.5;
                objects.antifragile.y = centerY;
                objects.antifragile.r = 30;
                objects.antifragile.targetR = 30;
            }

            initObjects();

            // --- Logic ---

            function spawnWeight() {
                // Spawn chance based on stress level
                // Low stress: rare drops. High stress: rain of weights.
                const spawnChance = 0.01 + (stressLevel * 0.08); 
                
                if (Math.random() < spawnChance) {
                    // Pick a random target (0, 1, or 2)
                    const targetIdx = Math.floor(Math.random() * 3);
                    const sectionWidth = width / 3;
                    const targetX = (sectionWidth * targetIdx) + (sectionWidth * 0.5);
                    
                    weights.push({
                        x: targetX + (Math.random() - 0.5) * 20, // Slight variance
                        y: -50,
                        vy: 2 + Math.random() * 3 + (stressLevel * 5), // Faster with stress
                        size: 15 + Math.random() * 10,
                        target: targetIdx // 0: Fragile, 1: Robust, 2: Antifragile
                    });
                }
            }

            function update() {
                spawnWeight();

                // Update Weights
                for (let i = weights.length - 1; i >= 0; i--) {
                    let w = weights[i];
                    w.y += w.vy;

                    // Collision Logic
                    const groundY = height * 0.7; // Objects sit here
                    
                    // Hit detection
                    if (w.y + w.size >= groundY - 30) { // Approx top of objects
                        let hit = false;
                        
                        // Check collision based on target column
                        if (w.target === 0) { // Fragile
                            if (objects.fragile.state === 'intact' && Math.abs(w.x - objects.fragile.x) < 40) {
                                hit = true;
                                objects.fragile.state = 'broken';
                                // Create shards
                                for(let k=0; k<8; k++) {
                                    objects.fragile.shards.push({
                                        x: objects.fragile.x,
                                        y: objects.fragile.y - 30,
                                        vx: (Math.random() - 0.5) * 15,
                                        vy: (Math.random() - 1) * 15,
                                        rot: Math.random() * 6,
                                        vRot: (Math.random() - 0.5) * 0.5
                                    });
                                }
                                createImpactParticles(w.x, w.y, colors.fragile);
                            }
                        } else if (w.target === 1) { // Robust
                            if (Math.abs(w.x - objects.robust.x) < 40) {
                                hit = true;
                                objects.robust.offset = 5; // Shake down
                                // Bounce weight away? No, just destroy weight with spark
                                createImpactParticles(w.x, w.y, colors.robust);
                            }
                        } else if (w.target === 2) { // Antifragile
                            if (Math.abs(w.x - objects.antifragile.x) < objects.antifragile.r + 10) {
                                hit = true;
                                // Absorb!
                                objects.antifragile.targetR = Math.min(80, objects.antifragile.targetR + 5);
                                createImpactParticles(w.x, w.y, colors.antifragile, true); // Absorption effect
                            }
                        }

                        if (hit || w.y > height) {
                            weights.splice(i, 1);
                            continue;
                        }
                    }
                }

                // Update Objects
                
                // Fragile Logic
                if (objects.fragile.state === 'broken') {
                    // Update shards
                    objects.fragile.shards.forEach(s => {
                        s.x += s.vx;
                        s.y += s.vy;
                        s.vy += 0.8; // Gravity
                        s.rot += s.vRot;
                    });
                    
                    // Auto-repair slowly (magic)
                    if (Math.random() < 0.005) {
                        objects.fragile.state = 'intact';
                    }
                }

                // Robust Logic
                if (objects.robust.offset > 0) {
                    objects.robust.offset *= 0.8;
                    if (objects.robust.offset < 0.1) objects.robust.offset = 0;
                }

                // Antifragile Logic
                // Constant slow decay (entropy)
                objects.antifragile.targetR = Math.max(30, objects.antifragile.targetR - 0.05);
                // Smooth interpolation
                objects.antifragile.r += (objects.antifragile.targetR - objects.antifragile.r) * 0.1;
                objects.antifragile.pulse += 0.05;

                // Update Particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    let p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.02;
                    if (p.life <= 0) particles.splice(i, 1);
                }
            }

            function createImpactParticles(x, y, color, isAbsorb = false) {
                const count = isAbsorb ? 5 : 8;
                for(let i=0; i<count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = isAbsorb ? -2 : (2 + Math.random() * 3); // Suck in if absorb
                    particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color: color,
                        life: 1.0,
                        size: 2 + Math.random() * 3
                    });
                }
            }

            function draw() {
                if (!ctx || !isRunning) return;
                
                // DOM Check
                if (!document.body.contains(canvas)) {
                    isRunning = false;
                    resizeObserver.disconnect();
                    slider.removeEventListener('input', onInput);
                    return;
                }

                ctx.clearRect(0, 0, width, height);

                const groundY = height * 0.7;

                // Draw Floor
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, groundY);
                ctx.lineTo(width, groundY);
                ctx.stroke();

                // 1. Draw Fragile (Box)
                if (objects.fragile.state === 'intact') {
                    ctx.fillStyle = colors.fragile;
                    ctx.fillRect(objects.fragile.x - 30, objects.fragile.y - 60, 60, 60);
                    
                    // "Fragile" Label/Icon
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.beginPath();
                    // Broken glass icon
                    ctx.moveTo(objects.fragile.x - 10, objects.fragile.y - 45);
                    ctx.lineTo(objects.fragile.x + 5, objects.fragile.y - 35);
                    ctx.lineTo(objects.fragile.x - 5, objects.fragile.y - 25);
                    ctx.lineTo(objects.fragile.x + 10, objects.fragile.y - 15);
                    ctx.stroke();
                } else {
                    // Draw Shards
                    ctx.fillStyle = colors.fragile;
                    objects.fragile.shards.forEach(s => {
                        ctx.save();
                        ctx.translate(s.x, s.y);
                        ctx.rotate(s.rot);
                        ctx.fillRect(-5, -5, 10, 10);
                        ctx.restore();
                    });
                }

                // 2. Draw Robust (Rock)
                ctx.fillStyle = colors.robust;
                const rY = objects.robust.y + objects.robust.offset;
                ctx.beginPath();
                ctx.arc(objects.robust.x, rY - 35, 35, Math.PI, 0); // Top half circle
                ctx.lineTo(objects.robust.x + 35, rY);
                ctx.lineTo(objects.robust.x - 35, rY);
                ctx.fill();
                // Add "Iron" sheen
                ctx.strokeStyle = '#64748b';
                ctx.beginPath();
                ctx.moveTo(objects.robust.x - 15, rY - 45);
                ctx.lineTo(objects.robust.x + 15, rY - 45);
                ctx.stroke();

                // 3. Draw Antifragile (Slime/Cell)
                ctx.fillStyle = colors.antifragile;
                const ar = objects.antifragile.r;
                // Wobble effect
                const wobble = Math.sin(objects.antifragile.pulse) * 2;
                
                ctx.beginPath();
                ctx.ellipse(objects.antifragile.x, objects.antifragile.y - ar + wobble, ar + wobble, ar - wobble, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Glow
                const gradient = ctx.createRadialGradient(objects.antifragile.x, objects.antifragile.y - ar, ar * 0.5, objects.antifragile.x, objects.antifragile.y - ar, ar * 2);
                gradient.addColorStop(0, 'rgba(16, 185, 129, 0.4)');
                gradient.addColorStop(1, 'rgba(16, 185, 129, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(objects.antifragile.x, objects.antifragile.y - ar, ar * 2, 0, Math.PI * 2);
                ctx.fill();

                // Draw Weights
                ctx.fillStyle = colors.weight;
                weights.forEach(w => {
                    ctx.beginPath();
                    ctx.rect(w.x - w.size/2, w.y, w.size, w.size);
                    ctx.fill();
                });

                // Draw Particles
                particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                });

                requestAnimationFrame(draw);
            }

            // Loop
            function loop() {
                if (!isRunning) return;
                update();
            }
            
            const updateInterval = setInterval(() => {
                if (!isRunning) {
                    clearInterval(updateInterval);
                    return;
                }
                update();
            }, 1000/60);

            draw();
            console.log("AntifragileCanvas: Animation started");
        }

        if (document.readyState !== 'loading') {
            initAntifragileCanvas();
        } else {
            document.addEventListener('DOMContentLoaded', initAntifragileCanvas);
        }
        document.addEventListener('astro:page-load', initAntifragileCanvas);
    })();
</script>